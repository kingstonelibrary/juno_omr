var __wpo = {
  "assets": {
    "main": [
      "./icons/apple-touch-icon-57x57.png",
      "./icons/apple-touch-icon-60x60.png",
      "./icons/apple-touch-icon-72x72.png",
      "./icons/apple-touch-icon-76x76.png",
      "./icons/apple-touch-icon-114x114.png",
      "./icons/apple-touch-icon-120x120.png",
      "./icons/apple-touch-icon-144x144.png",
      "./icons/apple-touch-icon-152x152.png",
      "./icons/apple-touch-icon-167x167.png",
      "./icons/apple-touch-icon-180x180.png",
      "./icons/apple-touch-icon.png",
      "./icons/apple-touch-icon-precomposed.png",
      "./icons/favicon-16x16.png",
      "./icons/favicon-32x32.png",
      "./icons/favicon.ico",
      "./icons/android-chrome-36x36.png",
      "./icons/android-chrome-48x48.png",
      "./icons/android-chrome-72x72.png",
      "./icons/android-chrome-96x96.png",
      "./icons/android-chrome-144x144.png",
      "./icons/android-chrome-192x192.png",
      "./icons/android-chrome-256x256.png",
      "./icons/android-chrome-384x384.png",
      "./icons/android-chrome-512x512.png",
      "./icons/mstile-70x70.png",
      "./icons/mstile-144x144.png",
      "./icons/mstile-150x150.png",
      "./icons/mstile-310x150.png",
      "./icons/mstile-310x310.png",
      "./icons/firefox_app_60x60.png",
      "./icons/firefox_app_128x128.png",
      "./icons/firefox_app_512x512.png",
      "./icons/apple-touch-startup-image-320x460.png",
      "./icons/apple-touch-startup-image-640x920.png",
      "./icons/apple-touch-startup-image-640x1096.png",
      "./icons/apple-touch-startup-image-748x1024.png",
      "./icons/apple-touch-startup-image-750x1294.png",
      "./icons/apple-touch-startup-image-768x1004.png",
      "./icons/apple-touch-startup-image-1182x2208.png",
      "./icons/apple-touch-startup-image-1242x2148.png",
      "./icons/apple-touch-startup-image-1496x2048.png",
      "./icons/apple-touch-startup-image-1536x2008.png",
      "./manifest.json",
      "./icons/browserconfig.xml",
      "./manifest.webapp",
      "./images/splash.jpg",
      "./images/sena1.png",
      "./images/sena2.png",
      "./images/sena3.png",
      "./images/sena4.png",
      "./images/sena5.png",
      "./images/sena6.png",
      "./app.bundle.js",
      "./"
    ],
    "additional": [],
    "optional": []
  },
  "externals": [],
  "hashesMap": {
    "41de12fd16903555a5c14f5333c21da7b1064a2c": "./icons/apple-touch-icon-57x57.png",
    "c2e51a7720b992ad5ff5940cd7b1dbb60f8efe8c": "./icons/apple-touch-icon-60x60.png",
    "6441f36369a73791d66a6edc3909dc5e0371b9d9": "./icons/android-chrome-72x72.png",
    "957309d0c05e9e92437f8c1db650fcea5220a5fa": "./icons/apple-touch-icon-76x76.png",
    "9c88896a9731dcdc5f3cc123a566e0d18c11b41d": "./icons/apple-touch-icon-114x114.png",
    "44193d204ed4de513fe31191a73aeac0e69615cf": "./icons/apple-touch-icon-120x120.png",
    "788007147d88bf913642b75aae22820d524fb7d5": "./icons/mstile-144x144.png",
    "54e466c449f5c1b8b8a8a138a180cfbb4baca1f8": "./icons/apple-touch-icon-152x152.png",
    "7d5ede04c718726757c173131f99813671033176": "./icons/apple-touch-icon-167x167.png",
    "67b22458c2dba77c1e60f2f0fff110c6c8baa568": "./icons/apple-touch-icon-precomposed.png",
    "d725b720b7f587ef340274d0b4f805c529147549": "./icons/favicon-16x16.png",
    "6e68b360f4da162107b1fed9895fc0c971165f9f": "./icons/favicon-32x32.png",
    "58033a16839e7f003a6c6bef6838d2ab7fbc0978": "./icons/favicon.ico",
    "4010b208085eea0f063146012e117789d6bcaf79": "./icons/android-chrome-36x36.png",
    "e77fe358fa114cd263e2476e8bce0a2fcdd874e8": "./icons/android-chrome-48x48.png",
    "6fa082f32b8ab1210929f73f347b0d78710dcf5a": "./icons/android-chrome-96x96.png",
    "2aea87c3ed6dc781c2d4edf7a2f129f44809d5fc": "./icons/android-chrome-192x192.png",
    "44af83e6bae29e932cdccffa12ca0d4e4cb010f7": "./icons/android-chrome-256x256.png",
    "a1c0982358bf34fe392368ee680772a6fc4be3bc": "./icons/android-chrome-384x384.png",
    "2ad7b0d26e3bd7804af7421bde1b70f9212afc59": "./icons/android-chrome-512x512.png",
    "3951ef78f871bb3ade6e73b7e74a0ba75f5730a5": "./icons/mstile-70x70.png",
    "422703af14cbf76e18e9d60001dc0803bb427f2a": "./icons/mstile-150x150.png",
    "8c1bfd677a09cf450ef48581f1ab300720ecbaaa": "./icons/mstile-310x150.png",
    "ff05e775943cbe33aec9449da3160f53de9d99c8": "./icons/mstile-310x310.png",
    "44e63c98e5eb13c3acbb63d2ce644ea180dcec40": "./icons/firefox_app_60x60.png",
    "a3071eb8bb65e13eba94d4e979d284b58aa1af49": "./icons/firefox_app_128x128.png",
    "635be12da461270f171c834a84c48a672540998e": "./icons/firefox_app_512x512.png",
    "fe4f67c37a24046abbfd7521d53a1d81912936bd": "./icons/apple-touch-startup-image-320x460.png",
    "8b23047693e9dfe5c60a28439c0b9ba7ad2a0c3a": "./icons/apple-touch-startup-image-640x920.png",
    "76c14dc55a4321c118c278ad2510c6799f364009": "./icons/apple-touch-startup-image-640x1096.png",
    "fd8299ef3a8cb93de1a82ceaa7127c4a403b1d53": "./icons/apple-touch-startup-image-748x1024.png",
    "a9f281994e693a229130b5f0e42e778c9daff9d6": "./icons/apple-touch-startup-image-750x1294.png",
    "3c58ebc97b3be9569ca231d85a9c7912b77bf2b1": "./icons/apple-touch-startup-image-768x1004.png",
    "0aa4bf6bda315c4324905b66e5757022ef9958f6": "./icons/apple-touch-startup-image-1182x2208.png",
    "84de49c84b32e51c4b17ca9c7d6e9179402f6e72": "./icons/apple-touch-startup-image-1242x2148.png",
    "4c693f7ec998d372028e8d8ea67c5f778ae1552f": "./icons/apple-touch-startup-image-1496x2048.png",
    "7d6fde69f57f292318d00e4904d5751b29b68203": "./icons/apple-touch-startup-image-1536x2008.png",
    "c9ad292bbc9a4d6ac0a7372cd411306c56177aa1": "./icons/manifest.json",
    "5b4f37d41ff649e9eeeb04ca9cc8b94c6757c986": "./icons/browserconfig.xml",
    "cdfbeeab1018af59c6777a20775cbdfccca50f75": "./icons/manifest.webapp",
    "3c7c640358d5454e58e167f3cae590dc297073dc": "./images/splash.jpg",
    "742a3cb86bc43aea855a5a992ac84582c083986c": "./images/sena1.png",
    "6c4422cfa88043f9e3568066fb19fefb8962abb4": "./images/sena2.png",
    "9425b134ef449f8bbc6ef1f3edd6c35f8c9606e0": "./images/sena3.png",
    "581904ce5bdead6ad5841bc17f949136f239e2d0": "./images/sena4.png",
    "aabec89e8ab44da6cba8f0f05aa8f75082b4f7ff": "./images/sena5.png",
    "7f34b875fdc95080a20fa8b184ffbfa107b8fc89": "./images/sena6.png",
    "3f471cc10ccd93036d7a7bb0ace74647612b8be0": "./app.bundle.js",
    "ac28116f424d5c2c8e9f8785d9148532497d03bb": "./"
  },
  "strategy": "changed",
  "responseStrategy": "cache-first",
  "version": "2019-8-20 12:32:28",
  "name": "webpack-offline",
  "pluginVersion": "5.0.6",
  "relativePaths": true
};


self.addEventListener("fetch", function(event) {
  console.log("[SW] fetch event (global scope fecth handler)");
});
self.addEventListener("push", function(event) {
  //送られたプッシュ通知の本文を表示
  if (Notification.permission == "granted") {
    console.log("[SW] Push Notification Recieved", event);
    event.waitUntil(
      self.registration
        .showNotification(event.data.json().notification.title, {
          body: event.data.json().notification.body,
          icon: event.data.json().notification.icon
        })
        .then(
          function(showEvent) {},
          function(error) {
            console.log(error);
          }
        )
    );
  }
});

/******/ (function(modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/ var installedModules = {}; // The require function
  /******/
  /******/ /******/ function __webpack_require__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/ if (installedModules[moduleId]) {
      /******/ return installedModules[moduleId].exports;
      /******/
    } // Create a new module (and put it into the cache)
    /******/ /******/ var module = (installedModules[moduleId] = {
      /******/ i: moduleId,
      /******/ l: false,
      /******/ exports: {}
      /******/
    }); // Execute the module function
    /******/
    /******/ /******/ modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    ); // Flag the module as loaded
    /******/
    /******/ /******/ module.l = true; // Return the exports of the module
    /******/
    /******/ /******/ return module.exports;
    /******/
  } // expose the modules object (__webpack_modules__)
  /******/
  /******/
  /******/ /******/ __webpack_require__.m = modules; // expose the module cache
  /******/
  /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
  /******/
  /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
    /******/ if (!__webpack_require__.o(exports, name)) {
      /******/ Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter
      });
      /******/
    }
    /******/
  }; // define __esModule on exports
  /******/
  /******/ /******/ __webpack_require__.r = function(exports) {
    /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      /******/ Object.defineProperty(exports, Symbol.toStringTag, {
        value: "Module"
      });
      /******/
    }
    /******/ Object.defineProperty(exports, "__esModule", { value: true });
    /******/
  }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
  /******/
  /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
    value,
    mode
  ) {
    /******/ if (mode & 1) value = __webpack_require__(value);
    /******/ if (mode & 8) return value;
    /******/ if (
      mode & 4 &&
      typeof value === "object" &&
      value &&
      value.__esModule
    )
      return value;
    /******/ var ns = Object.create(null);
    /******/ __webpack_require__.r(ns);
    /******/ Object.defineProperty(ns, "default", {
      enumerable: true,
      value: value
    });
    /******/ if (mode & 2 && typeof value != "string")
      for (var key in value)
        __webpack_require__.d(
          ns,
          key,
          function(key) {
            return value[key];
          }.bind(null, key)
        );
    /******/ return ns;
    /******/
  }; // getDefaultExport function for compatibility with non-harmony modules
  /******/
  /******/ /******/ __webpack_require__.n = function(module) {
    /******/ var getter =
      module && module.__esModule
        ? /******/ function getDefault() {
            return module["default"];
          }
        : /******/ function getModuleExports() {
            return module;
          };
    /******/ __webpack_require__.d(getter, "a", getter);
    /******/ return getter;
    /******/
  }; // Object.prototype.hasOwnProperty.call
  /******/
  /******/ /******/ __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }; // __webpack_public_path__
  /******/
  /******/ /******/ __webpack_require__.p = ""; // Load entry module and return exports
  /******/
  /******/
  /******/ /******/ return __webpack_require__((__webpack_require__.s = 0));
  /******/
})(
  /************************************************************************/
  /******/ [
    /* 0 */
    /***/ function(module, exports, __webpack_require__) {
      "use strict";

      (function() {
        var waitUntil = ExtendableEvent.prototype.waitUntil;
        var respondWith = FetchEvent.prototype.respondWith;
        var promisesMap = new WeakMap();

        ExtendableEvent.prototype.waitUntil = function(promise) {
          var extendableEvent = this;
          var promises = promisesMap.get(extendableEvent);

          if (promises) {
            promises.push(Promise.resolve(promise));
            return;
          }

          promises = [Promise.resolve(promise)];
          promisesMap.set(extendableEvent, promises);

          // call original method
          return waitUntil.call(
            extendableEvent,
            Promise.resolve().then(function processPromises() {
              var len = promises.length;

              // wait for all to settle
              return Promise.all(
                promises.map(function(p) {
                  return p["catch"](function() {});
                })
              ).then(function() {
                // have new items been added? If so, wait again
                if (promises.length != len) return processPromises();
                // we're done!
                promisesMap["delete"](extendableEvent);
                // reject if one of the promises rejected
                return Promise.all(promises);
              });
            })
          );
        };

        FetchEvent.prototype.respondWith = function(promise) {
          this.waitUntil(promise);
          return respondWith.call(this, promise);
        };
      })();
      ("use strict");

      if (typeof DEBUG === "undefined") {
        var DEBUG = false;
      }

      function WebpackServiceWorker(params, helpers) {
        var cacheMaps = helpers.cacheMaps;
        // navigationPreload: true, { map: (URL) => URL, test: (URL) => boolean }
        var navigationPreload = helpers.navigationPreload;

        // (update)strategy: changed, all
        var strategy = params.strategy;
        // responseStrategy: cache-first, network-first
        var responseStrategy = params.responseStrategy;

        var assets = params.assets;

        var hashesMap = params.hashesMap;
        var externals = params.externals;

        var prefetchRequest = params.prefetchRequest || {
          credentials: "same-origin",
          mode: "cors"
        };

        var CACHE_PREFIX = params.name;
        var CACHE_TAG = params.version;
        var CACHE_NAME = CACHE_PREFIX + ":" + CACHE_TAG;

        var PRELOAD_CACHE_NAME = CACHE_PREFIX + "$preload";
        var STORED_DATA_KEY = "__offline_webpack__data";

        mapAssets();

        var allAssets = [].concat(
          assets.main,
          assets.additional,
          assets.optional
        );

        self.addEventListener("install", function(event) {
          console.log("[SW] ", "Install event");
          caches.delete(CACHE_NAME);
          var installing = undefined;

          if (strategy === "changed") {
            installing = cacheChanged("main");
          } else {
            installing = cacheAssets("main");
          }

          event.waitUntil(installing);
          event.waitUntil(self.skipWaiting());
        });

        self.addEventListener("activate", function(event) {
          console.log("[SW] ", "Activate event");

          var activation = cacheAdditional();

          // Delete all assets which name starts with CACHE_PREFIX and
          // is not current cache (CACHE_NAME)
          activation = activation.then(storeCacheData);
          activation = activation.then(deleteObsolete);
          activation = activation.then(function() {
            if (self.clients && self.clients.claim) {
              console.log("[SW] claim() was executed!");

              return self.clients.claim();
            }
          });

          if (navigationPreload && self.registration.navigationPreload) {
            activation = Promise.all([
              activation,
              self.registration.navigationPreload.enable()
            ]);
          }

          event.waitUntil(activation);
        });

        function cacheAdditional() {
          if (!assets.additional.length) {
            return Promise.resolve();
          }

          if (DEBUG) {
            console.log("[SW] ", "Caching additional");
          }

          var operation = undefined;

          if (strategy === "changed") {
            operation = cacheChanged("additional");
          } else {
            operation = cacheAssets("additional");
          }

          // Ignore fail of `additional` cache section
          return operation["catch"](function(e) {
            console.error("[SW] ", "Cache section `additional` failed to load");
          });
        }

        function cacheAssets(section) {
          var batch = assets[section];

          return caches
            .open(CACHE_NAME)
            .then(function(cache) {
              return addAllNormalized(cache, batch, {
                bust: params.version,
                request: prefetchRequest,
                failAll: section === "main"
              });
            })
            .then(function() {
              logGroup("Cached assets: " + section, batch);
            })
            ["catch"](function(e) {
              console.error(e);
              throw e;
            });
        }

        function cacheChanged(section) {
          return getLastCache().then(function(args) {
            if (!args) {
              return cacheAssets(section);
            }

            var lastCache = args[0];
            var lastKeys = args[1];
            var lastData = args[2];

            var lastMap = lastData.hashmap;
            var lastVersion = lastData.version;

            if (!lastData.hashmap || lastVersion === params.version) {
              return cacheAssets(section);
            }

            var lastHashedAssets = Object.keys(lastMap).map(function(hash) {
              return lastMap[hash];
            });

            var lastUrls = lastKeys.map(function(req) {
              var url = new URL(req.url);
              url.search = "";
              url.hash = "";

              return url.toString();
            });

            var sectionAssets = assets[section];
            var moved = [];
            var changed = sectionAssets.filter(function(url) {
              if (
                lastUrls.indexOf(url) === -1 ||
                lastHashedAssets.indexOf(url) === -1
              ) {
                return true;
              }

              return false;
            });

            Object.keys(hashesMap).forEach(function(hash) {
              var asset = hashesMap[hash];

              // Return if not in sectionAssets or in changed or moved array
              if (
                sectionAssets.indexOf(asset) === -1 ||
                changed.indexOf(asset) !== -1 ||
                moved.indexOf(asset) !== -1
              )
                return;

              var lastAsset = lastMap[hash];

              if (lastAsset && lastUrls.indexOf(lastAsset) !== -1) {
                moved.push([lastAsset, asset]);
              } else {
                changed.push(asset);
              }
            });

            logGroup("[SW] Changed assets: " + section, changed);
            logGroup("[SW] Moved assets: " + section, moved);

            var movedResponses = Promise.all(
              moved.map(function(pair) {
                return lastCache.match(pair[0]).then(function(response) {
                  return [pair[1], response];
                });
              })
            );

            return caches.open(CACHE_NAME).then(function(cache) {
              var move = movedResponses.then(function(responses) {
                return Promise.all(
                  responses.map(function(pair) {
                    return cache.put(pair[0], pair[1]);
                  })
                );
              });

              return Promise.all([
                move,
                addAllNormalized(cache, changed, {
                  bust: params.version,
                  request: prefetchRequest,
                  failAll: section === "main",
                  deleteFirst: section !== "main"
                })
              ]);
            });
          });
        }

        function deleteObsolete() {
          return caches.keys().then(function(keys) {
            var all = keys.map(function(key) {
              if (
                key.indexOf(CACHE_PREFIX) !== 0 ||
                key.indexOf(CACHE_NAME) === 0
              )
                return;

              console.log("[SW] ", "Delete cache:", key);
              return caches["delete"](key);
            });

            return Promise.all(all);
          });
        }

        function getLastCache() {
          return caches.keys().then(function(keys) {
            var index = keys.length;
            var key = undefined;

            while (index--) {
              key = keys[index];

              if (key.indexOf(CACHE_PREFIX) === 0) {
                break;
              }
            }

            if (!key) return;

            var cache = undefined;

            return caches
              .open(key)
              .then(function(_cache) {
                cache = _cache;
                return _cache.match(
                  new URL(STORED_DATA_KEY, location).toString()
                );
              })
              .then(function(response) {
                if (!response) return;

                return Promise.all([cache, cache.keys(), response.json()]);
              });
          });
        }

        function storeCacheData() {
          return caches.open(CACHE_NAME).then(function(cache) {
            var data = new Response(
              JSON.stringify({
                version: params.version,
                hashmap: hashesMap
              })
            );

            return cache.put(
              new URL(STORED_DATA_KEY, location).toString(),
              data
            );
          });
        }

        self.addEventListener("fetch", function(event) {
          // Handle only GET requests
          if (event.request.method !== "GET") {
            return;
          }

          console.log("[SW] fetch event (inner scope fecth handler)		");

          // This prevents some weird issue with Chrome DevTools and 'only-if-cached'
          // Fixes issue #385, also ref to:
          // - https://github.com/paulirish/caltrainschedule.io/issues/49
          // - https://bugs.chromium.org/p/chromium/issues/detail?id=823392
          if (
            event.request.cache === "only-if-cached" &&
            event.request.mode !== "same-origin"
          ) {
            return;
          }

          var url = new URL(event.request.url);
          url.hash = "";

          var urlString = url.toString();

          // Not external, so search part of the URL should be stripped,
          // if it's external URL, the search part should be kept
          if (externals.indexOf(urlString) === -1) {
            url.search = "";
            urlString = url.toString();
          }

          var assetMatches = allAssets.indexOf(urlString) !== -1;
          var cacheUrl = urlString;

          if (!assetMatches) {
            var cacheRewrite = matchCacheMap(event.request);

            if (cacheRewrite) {
              cacheUrl = cacheRewrite;
              assetMatches = true;
            }
          }

          if (!assetMatches) {
            // Use request.mode === 'navigate' instead of isNavigateRequest
            // because everything what supports navigationPreload supports
            // 'navigate' request.mode
            if (event.request.mode === "navigate") {
              // Requesting with fetchWithPreload().
              // Preload is used only if navigationPreload is enabled and
              // navigationPreload mapping is not used.
              if (navigationPreload === true) {
                event.respondWith(fetchWithPreload(event));
                return;
              }
            }

            // Something else, positive, but not `true`
            if (navigationPreload) {
              var preloadedResponse = retrivePreloadedResponse(event);

              if (preloadedResponse) {
                event.respondWith(preloadedResponse);
                return;
              }
            }

            // Logic exists here if no cache match
            return;
          }

          // Cache handling/storing/fetching starts here
          var resource = undefined;

          if (responseStrategy === "network-first") {
            resource = networkFirstResponse(event, urlString, cacheUrl);
          }
          // 'cache-first' otherwise
          // (responseStrategy has been validated before)
          else {
            resource = cacheFirstResponse(event, urlString, cacheUrl);
          }

          event.respondWith(resource);
        });

        self.addEventListener("message", function(e) {
          if (e.data === "updateDESU!") {
            console.log("[SW] received updateDESU & delete→" + CACHE_NAME);
            caches.delete(CACHE_NAME); // ブラウザ側(main.js)からSWスクリプト更新時イベントで受け取ったメッセージならキャッシュ削除
          }
          var data = e.data;
          if (!data) return;

          switch (data.action) {
            case "skipWaiting":
              {
                if (self.skipWaiting) self.skipWaiting();
              }
              break;
          }
        });

        function cacheFirstResponse(event, urlString, cacheUrl) {
          handleNavigationPreload(event);

          return cachesMatch(cacheUrl, CACHE_NAME).then(function(response) {
            if (response) {
              if (DEBUG) {
                console.log(
                  "[SW] ",
                  "URL [" + cacheUrl + "](" + urlString + ") from cache"
                );
              }

              return response;
            }

            // Load and cache known assets
            var fetching = fetch(event.request).then(function(response) {
              if (!response.ok) {
                if (DEBUG) {
                  console.log(
                    "[SW] ",
                    "URL [" +
                      urlString +
                      "] wrong response: [" +
                      response.status +
                      "] " +
                      response.type
                  );
                }

                return response;
              }

              if (DEBUG) {
                console.log("[SW] ", "URL [" + urlString + "] from network");
              }

              if (cacheUrl === urlString) {
                (function() {
                  var responseClone = response.clone();
                  var storing = caches
                    .open(CACHE_NAME)
                    .then(function(cache) {
                      return cache.put(urlString, responseClone);
                    })
                    .then(function() {
                      console.log("[SW] ", "Cache asset: " + urlString);
                    });

                  event.waitUntil(storing);
                })();
              }

              return response;
            });

            return fetching;
          });
        }

        function networkFirstResponse(event, urlString, cacheUrl) {
          return fetchWithPreload(event)
            .then(function(response) {
              if (response.ok) {
                if (DEBUG) {
                  console.log("[SW] ", "URL [" + urlString + "] from network");
                }

                return response;
              }

              // Throw to reach the code in the catch below
              throw response;
            })
            [
              // This needs to be in a catch() and not just in the then() above
              // cause if your network is down, the fetch() will throw
              "catch"
            ](function(erroredResponse) {
              if (DEBUG) {
                console.log(
                  "[SW] ",
                  "URL [" + urlString + "] from cache if possible"
                );
              }

              return cachesMatch(cacheUrl, CACHE_NAME).then(function(response) {
                if (response) {
                  return response;
                }

                if (erroredResponse instanceof Response) {
                  return erroredResponse;
                }

                // Not a response at this point, some other error
                throw erroredResponse;
                // return Response.error();
              });
            });
        }

        function handleNavigationPreload(event) {
          if (
            navigationPreload &&
            typeof navigationPreload.map === "function" &&
            // Use request.mode === 'navigate' instead of isNavigateRequest
            // because everything what supports navigationPreload supports
            // 'navigate' request.mode
            event.preloadResponse &&
            event.request.mode === "navigate"
          ) {
            var mapped = navigationPreload.map(
              new URL(event.request.url),
              event.request
            );

            if (mapped) {
              storePreloadedResponse(mapped, event);
            }
          }
        }

        // Temporary in-memory store for faster access
        var navigationPreloadStore = new Map();

        function storePreloadedResponse(_url, event) {
          var url = new URL(_url, location);
          var preloadResponsePromise = event.preloadResponse;

          navigationPreloadStore.set(preloadResponsePromise, {
            url: url,
            response: preloadResponsePromise
          });

          var isSamePreload = function isSamePreload() {
            return navigationPreloadStore.has(preloadResponsePromise);
          };

          var storing = preloadResponsePromise.then(function(res) {
            // Return if preload isn't enabled or hasn't happened
            if (!res) return;

            // If navigationPreloadStore already consumed
            // or navigationPreloadStore already contains another preload,
            // then do not store anything and return
            if (!isSamePreload()) {
              return;
            }

            var clone = res.clone();

            // Storing the preload response for later consume (hasn't yet been consumed)
            return caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
              if (!isSamePreload()) return;

              return cache.put(url, clone).then(function() {
                if (!isSamePreload()) {
                  return caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
                    return cache["delete"](url);
                  });
                }
              });
            });
          });

          event.waitUntil(storing);
        }

        function retriveInMemoryPreloadedResponse(url) {
          if (!navigationPreloadStore) {
            return;
          }

          var foundResponse = undefined;
          var foundKey = undefined;

          navigationPreloadStore.forEach(function(store, key) {
            if (store.url.href === url.href) {
              foundResponse = store.response;
              foundKey = key;
            }
          });

          if (foundResponse) {
            navigationPreloadStore["delete"](foundKey);
            return foundResponse;
          }
        }

        function retrivePreloadedResponse(event) {
          var url = new URL(event.request.url);

          if (
            self.registration.navigationPreload &&
            navigationPreload &&
            navigationPreload.test &&
            navigationPreload.test(url, event.request)
          ) {
          } else {
            return;
          }

          var fromMemory = retriveInMemoryPreloadedResponse(url);
          var request = event.request;

          if (fromMemory) {
            event.waitUntil(
              caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
                return cache["delete"](request);
              })
            );

            return fromMemory;
          }

          return cachesMatch(request, PRELOAD_CACHE_NAME).then(function(
            response
          ) {
            if (response) {
              event.waitUntil(
                caches.open(PRELOAD_CACHE_NAME).then(function(cache) {
                  return cache["delete"](request);
                })
              );
            }

            return response || fetch(event.request);
          });
        }

        function mapAssets() {
          Object.keys(assets).forEach(function(key) {
            assets[key] = assets[key].map(function(path) {
              var url = new URL(path, location);

              url.hash = "";

              if (externals.indexOf(path) === -1) {
                url.search = "";
              }

              return url.toString();
            });
          });

          hashesMap = Object.keys(hashesMap).reduce(function(result, hash) {
            var url = new URL(hashesMap[hash], location);
            url.search = "";
            url.hash = "";

            result[hash] = url.toString();
            return result;
          }, {});

          externals = externals.map(function(path) {
            var url = new URL(path, location);
            url.hash = "";

            return url.toString();
          });
        }

        function addAllNormalized(cache, requests, options) {
          var bustValue = options.bust;
          var failAll = options.failAll !== false;
          var deleteFirst = options.deleteFirst === true;
          var requestInit = options.request || {
            credentials: "omit",
            mode: "cors"
          };

          var deleting = Promise.resolve();

          if (deleteFirst) {
            deleting = Promise.all(
              requests.map(function(request) {
                return cache["delete"](request)["catch"](function() {});
              })
            );
          }

          return Promise.all(
            requests.map(function(request) {
              if (bustValue) {
                request = applyCacheBust(request, bustValue);
              }

              return fetch(request, requestInit)
                .then(fixRedirectedResponse)
                .then(
                  function(response) {
                    if (!response.ok) {
                      return { error: true };
                    }

                    return { response: response };
                  },
                  function() {
                    return { error: true };
                  }
                );
            })
          ).then(function(responses) {
            if (
              failAll &&
              responses.some(function(data) {
                return data.error;
              })
            ) {
              return Promise.reject(new Error("Wrong response status"));
            }

            if (!failAll) {
              responses = responses.filter(function(data) {
                return !data.error;
              });
            }

            return deleting.then(function() {
              var addAll = responses.map(function(_ref, i) {
                var response = _ref.response;

                return cache.put(requests[i], response);
              });

              return Promise.all(addAll);
            });
          });
        }

        function matchCacheMap(request) {
          var urlString = request.url;
          var url = new URL(urlString);

          var requestType = undefined;

          if (isNavigateRequest(request)) {
            requestType = "navigate";
          } else if (url.origin === location.origin) {
            requestType = "same-origin";
          } else {
            requestType = "cross-origin";
          }

          for (var i = 0; i < cacheMaps.length; i++) {
            var map = cacheMaps[i];

            if (!map) continue;
            if (
              map.requestTypes &&
              map.requestTypes.indexOf(requestType) === -1
            ) {
              continue;
            }

            var newString = undefined;

            if (typeof map.match === "function") {
              newString = map.match(url, request);
            } else {
              newString = urlString.replace(map.match, map.to);
            }

            if (newString && newString !== urlString) {
              return newString;
            }
          }
        }

        function fetchWithPreload(event) {
          if (!event.preloadResponse || navigationPreload !== true) {
            return fetch(event.request);
          }

          return event.preloadResponse.then(function(response) {
            return response || fetch(event.request);
          });
        }
      }

      function cachesMatch(request, cacheName) {
        return caches
          .match(request, {
            cacheName: cacheName
          })
          .then(function(response) {
            if (isNotRedirectedResponse(response)) {
              return response;
            }

            // Fix already cached redirected responses
            return fixRedirectedResponse(response).then(function(
              fixedResponse
            ) {
              return caches
                .open(cacheName)
                .then(function(cache) {
                  return cache.put(request, fixedResponse);
                })
                .then(function() {
                  return fixedResponse;
                });
            });
          })
          [
            // Return void if error happened (cache not found)
            "catch"
          ](function() {});
      }

      function applyCacheBust(asset, key) {
        var hasQuery = asset.indexOf("?") !== -1;
        return (
          asset +
          (hasQuery ? "&" : "?") +
          "__uncache=" +
          encodeURIComponent(key)
        );
      }

      function isNavigateRequest(request) {
        return (
          request.mode === "navigate" ||
          request.headers.get("Upgrade-Insecure-Requests") ||
          (request.headers.get("Accept") || "").indexOf("text/html") !== -1
        );
      }

      function isNotRedirectedResponse(response) {
        return (
          !response ||
          !response.redirected ||
          !response.ok ||
          response.type === "opaqueredirect"
        );
      }

      // Based on https://github.com/GoogleChrome/sw-precache/pull/241/files#diff-3ee9060dc7a312c6a822cac63a8c630bR85
      function fixRedirectedResponse(response) {
        if (isNotRedirectedResponse(response)) {
          return Promise.resolve(response);
        }

        var body =
          "body" in response ? Promise.resolve(response.body) : response.blob();

        return body.then(function(data) {
          return new Response(data, {
            headers: response.headers,
            status: response.status
          });
        });
      }

      function copyObject(original) {
        return Object.keys(original).reduce(function(result, key) {
          result[key] = original[key];
          return result;
        }, {});
      }

      function logGroup(title, assets) {
        console.groupCollapsed("[SW] ", title);

        assets.forEach(function(asset) {
          console.log("Asset:", asset);
        });

        console.groupEnd();
      }
      WebpackServiceWorker(__wpo, {
        loaders: {},
        cacheMaps: [],
        navigationPreload: false
      });
      module.exports = __webpack_require__(1);

      /***/
    },
    /* 1 */
    /***/ function(module, exports) {
      /***/
    }
    /******/
  ]
);
